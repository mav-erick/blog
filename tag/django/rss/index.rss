<rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:media="http://search.yahoo.com/mrss/" version="2.0"><channel><title>Django - The Code Journal</title><description>Python, JavaScript and more</description><link>http://localhost:2368/</link><image><url>http://localhost:2368/favicon.png</url><title>Django - The Code Journal</title><link>http://localhost:2368/</link></image><generator>Ghost 1.25</generator><lastBuildDate>Sun, 29 Jul 2018 05:03:29 GMT</lastBuildDate><atom:link href="http://localhost:2368/tag/django/rss/" rel="self" type="application/rss+xml"/><ttl>60</ttl><item><title>Setting up Django Channels on AWS Elastic Beanstalk</title><description>Step by step guide to host a Django Channels application on AWS Elastic Beanstalk.</description><link>http://localhost:2368/setting-up-django-channels-on-aws-elastic-beanstalk/</link><guid isPermaLink="false">5b5d2d55550d572610b60764</guid><category>Django</category><category>AWS</category><category>Elastic-Beanstalk</category><category>Django-Channels</category><dc:creator>Abhishek Menon</dc:creator><pubDate>Tue, 21 Nov 2017 01:25:00 GMT</pubDate><media:content url="http://localhost:2368/content/images/2018/07/photo-1518481852452-9415b262eba4.jpeg" medium="image"/><content:encoded>&lt;h1 id="setting-up-django-channels-on-aws-elastic-beanstalk"&gt;Setting up Django Channels on AWS Elastic Beanstalk&lt;/h1&gt;&lt;img src="http://localhost:2368/content/images/2018/07/photo-1518481852452-9415b262eba4.jpeg" alt="Setting up Django Channels on AWS Elastic Beanstalk"&gt;&lt;p&gt;&lt;strong&gt;&lt;strong&gt;TL;DR&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;strong&gt;UPDATE: This tutorial is for Channels 1.X and not for Channels 2.x. Please leave me a note if you guys want to see another tutorial for Channels 2.&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;Django has always been one of the outliers in the modern era of real-time, asynchronous frameworks and libraries. If you want to build a chat application, for example, Django, most probably wouldn’t be your first choice. However, for those of you out there who hate JavaScript, or if you’re a “perfectionist with a deadline”, Django Channels presents you with a great option.&lt;/p&gt;&lt;p&gt;Django Channels is a library which brings the power of asynchronous web to Django. If you aren’t familiar with Django Channels, I highly recommend getting yourself familiarised with it before you read further. There are excellent articles out there explaining what Django Channels is, and how it can transform the way you use Django. These articles by &lt;a href="https://realpython.com/blog/python/getting-started-with-django-channels/" rel="noopener"&gt;real python&lt;/a&gt; and &lt;a href="https://blog.heroku.com/in_deep_with_django_channels_the_future_of_real_time_apps_in_django" rel="nofollow noopener"&gt;heroku&lt;/a&gt; are two great examples. It also shows you how to build a basic chat application using Channels. It is fairly straightforward to set up, and will get you going in a few minutes!&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;strong&gt;The problems with hosting a Django Channels Application&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;In traditional Django, requests are handled by the Django application itself. It looks at the request and URL, determines the correct view function to execute, executes it, produces a response and sends the response back to the user. Fairly straightforward. Django Channels, however, introduces an Interface Server (Daphne) in between. This means that the Interface server now communicates with the outside world. The interface server looks at the request and URL, determines the right “Channel”, process the request and creates a “message” for the worker process to consume, and places the message in that Channel. A message broker, like Redis, listens to these Channels, and delivers the messages to worker processes. The worker process listens to the message queue, processes the message (much like a view function) and produces the response and sends it back to the interface server, which then delivers it back to the user. (Please feel free to take a minute to grasp this, it took me many hours :’))&lt;/p&gt;&lt;p&gt;This means now, instead of just a single process running, which you would be starting using:&lt;/p&gt;&lt;p&gt;&lt;code&gt;python manage.py runserver&lt;/code&gt;&lt;/p&gt;&lt;p&gt;You would be running:&lt;/p&gt;&lt;p&gt;&lt;code&gt;daphne -p 8000 your_app.asgi:channel_layer&lt;/code&gt;&lt;/p&gt;&lt;p&gt;and&lt;/p&gt;&lt;p&gt;&lt;code&gt;python manage.py runworker&lt;/code&gt;&lt;/p&gt;&lt;p&gt;This enables Django Channels to support multiple types of requests (HTTP, Websockets etc). But clearly, it requires more resources than a standard Django application. For one, it requires a message broker. You can get away with an in memory message broker, but it is not recommended for production purposes. In this example, we will setup Redis in an EC2 instance and use that as the message broker.&lt;/p&gt;&lt;p&gt;If you’re using Elastic Beanstalk, it is configured to listen to port 80 by default, which is where generally your worker process will be running. But we want the application to listen to Daphne instead, so that would require configuring the Load Balancer to forward requests to the port where Daphne is listening.&lt;/p&gt;&lt;p&gt;But before all that, we first need to host our Django Application itself. If you are not familiar with how to do that, please follow the steps here:&lt;/p&gt;&lt;p&gt;&lt;a href="https://realpython.com/blog/python/deploying-a-django-app-and-postgresql-to-aws-elastic-beanstalk/"&gt;&lt;strong&gt;Deploying Django + Python 3 + PostgreSQL to AWS Elastic Beanstalk&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;&lt;h4 id="the-only-change-is-that-you-should-select-the-application-load-balancer-instead-of-the-classic-load-balancer-as-websockets-is-only-natively-supported-by-application-load-balancer-"&gt;The only change is that you should &lt;strong&gt;select the Application Load Balancer instead of the Classic Load Balancer as WebSockets is only natively supported by Application Load Balancer&lt;/strong&gt;.&lt;/h4&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;strong&gt;Next Steps:&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;Now we need to provision Redis for the channel layer. We can do this in two ways:&lt;/p&gt;&lt;p&gt;1.A. Provisioning a Redis Instance from EC2&lt;/p&gt;&lt;p&gt;1.B. Using ElastiCache&lt;/p&gt;&lt;p&gt;You can pick either one, but please note that &lt;strong&gt;&lt;strong&gt;ElastiCache includes a&lt;/strong&gt;&lt;/strong&gt; &lt;strong&gt;&lt;strong&gt;free tier&lt;/strong&gt;&lt;/strong&gt;as of the date of this post. &lt;strong&gt;&lt;strong&gt;You just need to do either 1.A or 1.B&lt;/strong&gt;&lt;/strong&gt;.&lt;/p&gt;&lt;h3 id="1-a-provisioning-a-redis-instance-for-message-broker"&gt;&lt;strong&gt;&lt;strong&gt;1.A. Provisioning a Redis Instance for message broker&lt;/strong&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;Sign in to your AWS console and go to EC2. Click “Launch Instance” on the top and select AWS Marketplace on the side menu.&lt;/p&gt;&lt;p&gt;Search for Redis 4.0&lt;/p&gt;&lt;figure class="kg-image-card"&gt;&lt;img src="http://localhost:2368/content/images/2018/07/1_XsKJ8BlqHZwoqPNPMMNpfQ--1--1.png" class="kg-image" alt="Setting up Django Channels on AWS Elastic Beanstalk"&gt;&lt;/figure&gt;&lt;p&gt;After this, follow through the next steps. Please be sure to store the ssh-key (pem file) for the instance. After that, click “Review and Launch”. This will get your Redis instance up and running.&lt;/p&gt;&lt;p&gt;Now ssh into your Redis instance and open &lt;code&gt;redis.conf&lt;/code&gt; file.&lt;/p&gt;&lt;p&gt;&lt;code&gt;sudo nano /jet/etc/redis/redis.conf&lt;/code&gt;&lt;/p&gt;&lt;p&gt;Change the address from &lt;code&gt;127.0.0.1&lt;/code&gt; to &lt;code&gt;0.0.0.0&lt;/code&gt; and port from &lt;code&gt;1999&lt;/code&gt; to &lt;code&gt;6379&lt;/code&gt;&lt;/p&gt;&lt;p&gt;Save and restart the using:&lt;/p&gt;&lt;p&gt;&lt;code&gt;sudo service restart redis&lt;/code&gt;&lt;/p&gt;&lt;p&gt;You can check everything is correctly configured by running &lt;code&gt;netstat -antpl&lt;/code&gt;&lt;/p&gt;&lt;p&gt;This command should show Redis running at 0.0.0.0:6379.&lt;/p&gt;&lt;p&gt;After this, select the instance from EC2 Dashboard, and in the menu below, select it’s security group (this should look something like Redis 4–0–170715-redis_4_0_0-AutogenByAWSMP). Add a new inbound rule with following info:&lt;/p&gt;&lt;p&gt;Type: Custom TCP Rule, Protocol: TCP, Port Range: 6379, Source: 0.0.0.0/0&lt;/p&gt;&lt;p&gt;You don’t need to add the above if it already exists or you can just modify the existing line if the port number is different. Now, grab the Public DNS of your Redis instance from EC2 Dashboard and save it for reference.&lt;/p&gt;&lt;h3 id="1-b-set-up-elasticache-with-redis-instance"&gt;1.B. &lt;strong&gt;&lt;strong&gt;Set up ElastiCache with Redis instance&lt;/strong&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;&lt;strong&gt;Credits for this section: &lt;/strong&gt;&lt;/strong&gt;&lt;a href="https://medium.com/@cpvandehey"&gt;&lt;strong&gt;&lt;strong&gt;Chad Van De Hey&lt;/strong&gt;&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;Sign into your AWS console and go to the ElastiCache service. Click to create a new ElastiCache cluster or if you have not created anything beforehand, click “Get Started”. We are going to be setting up an EC Redis cluster.&lt;/p&gt;&lt;p&gt;a. Click Redis as your cluster engine&lt;/p&gt;&lt;p&gt;b. Enter a name, description and choose the newest Engine version available.&lt;/p&gt;&lt;p&gt;c. Make sure the port is set to 6379.&lt;/p&gt;&lt;p&gt;d. Set the node type to the smallest available&lt;/p&gt;&lt;p&gt;e. Select t2 at the top -&amp;gt; select cache.t2.micro (for free tier)&lt;/p&gt;&lt;p&gt;f. Select “None” for Number of replicas and unselect “multi-az with auto-failover”.&lt;/p&gt;&lt;p&gt;g. Either select an existing subnet of your existing choices or create a new one selecting an AZ that is same as your EC2s.&lt;/p&gt;&lt;p&gt;h. Choose the security group of your EC2s that you created in Elastic Beanstalk.&lt;/p&gt;&lt;p&gt;i. Unselect “Enable automatic backups” and click “Create”&lt;/p&gt;&lt;p&gt;You will be redirected to your ElastiCache clusters/instances. Here you will see your instances been spun up and configured. After this process has completed, make sure to note down the url of the ElastiCache instance because you will need to configure your Django app with that later.&lt;/p&gt;&lt;h3 id="2-editing-the-django-configuration"&gt;2. Editing the Django Configuration&lt;/h3&gt;&lt;p&gt;Now in your &lt;code&gt;settings.py&lt;/code&gt; file for production, change your redis host and port to use the newly created Redis instance.&lt;/p&gt;&lt;pre&gt;&lt;code&gt;CHANNEL_LAYERS = {
 "default": {
  "BACKEND": "asgi_redis.RedisChannelLayer",
  "CONFIG": {
   "hosts": ["redis://(&amp;lt;The Public DNS of the Redis instance&amp;gt;, 6379)"],
  },
 "ROUTING": "&amp;lt;your_app&amp;gt;.routing.channel_routing", 
 }
}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Please change &amp;lt;your app&amp;gt; to the name of your app. This will configure your Django application to use the Redis instance we created.&lt;/p&gt;&lt;h3 id="3-running-daphne-server-and-a-worker-process-as-daemon"&gt;&lt;strong&gt;&lt;strong&gt;3. Running Daphne Server and a worker process as daemon&lt;/strong&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;&lt;/p&gt;&lt;script src="https://gist.github.com/mav-erick/8c8730e6578dc31dc32ee61c9bd9a83d.js"&gt;&lt;/script&gt;&lt;p&gt;Please change &amp;lt;your_project&amp;gt; to the name of your django app. This basically creates a script and places it in &lt;code&gt;/opt/elasticbeanstalk/hooks/appdeploy/post/&lt;/code&gt;&lt;/p&gt;&lt;p&gt;so that it executes &lt;strong&gt;&lt;strong&gt;after&lt;/strong&gt;&lt;/strong&gt; the application deploys. Now this script, in turn creates a supervisord conf script, which is responsible for running the daemon processes and managing the supervisord . (Again, please feel free to take a minute to grasp this :’) )&lt;/p&gt;&lt;h3 id="4-the-final-step-configure-the-alb"&gt;&lt;strong&gt;&lt;strong&gt;4. The final step: Configure the ALB&lt;/strong&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;Now we have our Redis set up, daphne and worker process running, now all we need to do is to configure our Application Load Balancer to forward the requests to our Daphne server which is listening on port 5000 (Please check the config script of the daemon processes).&lt;/p&gt;&lt;p&gt;Create a new file in your &lt;code&gt;.ebextensions&lt;/code&gt; folder called &lt;code&gt;alb_listener.config&lt;/code&gt;and place put the following code in.&lt;/p&gt;&lt;pre&gt;&lt;code&gt;option_settings:  
  aws:elbv2:listener:80:    
    DefaultProcess: http    
    ListenerEnabled: 'true'    
    Protocol: HTTP  
  aws:elasticbeanstalk:environment:process:http:    
    Port: '5000'    
    Protocol: HTTP&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Please be careful of the spaces as this is in YAML syntax.&lt;/p&gt;&lt;p&gt;Redeploy your app and Viola! your Django Channels app is up and running on AWS Elastic Beanstalk.&lt;/p&gt;&lt;p&gt;If you have any questions, please feel free to ask in the comments! Any recommendations for future blog posts is also welcome, if you like this one, that is. :’)&lt;/p&gt;&lt;p&gt;Thanks for reading!&lt;/p&gt;</content:encoded></item></channel></rss>